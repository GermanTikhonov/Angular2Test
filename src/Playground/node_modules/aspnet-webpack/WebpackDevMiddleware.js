"use strict";
var connect = require('connect');
var webpack = require('webpack');
var url = require('url');
var RequireNewCopy_1 = require('./RequireNewCopy');
function createWebpackDevServer(callback, optionsJson) {
    var options = JSON.parse(optionsJson);
    var webpackConfig = RequireNewCopy_1.requireNewCopy(options.webpackConfigPath);
    var publicPath = (webpackConfig.output.publicPath || '').trim();
    if (!publicPath) {
        callback('To use the Webpack dev server, you must specify a value for \'publicPath\' on the \'output\' section of your webpack.config.', null);
        return;
    }
    var enableHotModuleReplacement = options.suppliedOptions.HotModuleReplacement;
    var enableReactHotModuleReplacement = options.suppliedOptions.ReactHotModuleReplacement;
    if (enableReactHotModuleReplacement && !enableHotModuleReplacement) {
        callback('To use ReactHotModuleReplacement, you must also enable the HotModuleReplacement option.', null);
        return;
    }
    // The default value, 0, means 'choose randomly'
    var suggestedHMRPortOrZero = options.suppliedOptions.HotModuleReplacementServerPort || 0;
    var app = connect();
    var listener = app.listen(suggestedHMRPortOrZero, function () {
        // Build the final Webpack config based on supplied options
        if (enableHotModuleReplacement) {
            // For this, we only support the key/value config format, not string or string[], since
            // those ones don't clearly indicate what the resulting bundle name will be
            var entryPoints_1 = webpackConfig.entry;
            var isObjectStyleConfig = entryPoints_1
                && typeof entryPoints_1 === 'object'
                && !(entryPoints_1 instanceof Array);
            if (!isObjectStyleConfig) {
                callback('To use HotModuleReplacement, your webpack config must specify an \'entry\' value as a key-value object (e.g., "entry: { main: \'ClientApp/boot-client.ts\' }")', null);
                return;
            }
            // Augment all entry points so they support HMR
            Object.getOwnPropertyNames(entryPoints_1).forEach(function (entryPointName) {
                if (typeof entryPoints_1[entryPointName] === 'string') {
                    entryPoints_1[entryPointName] = ['webpack-hot-middleware/client', entryPoints_1[entryPointName]];
                }
                else {
                    entryPoints_1[entryPointName].unshift('webpack-hot-middleware/client');
                }
            });
            webpackConfig.plugins.push(new webpack.HotModuleReplacementPlugin());
            // Set up React HMR support if requested. This requires the 'aspnet-webpack-react' package.
            if (enableReactHotModuleReplacement) {
                var aspNetWebpackReactModule = void 0;
                try {
                    aspNetWebpackReactModule = require('aspnet-webpack-react');
                }
                catch (ex) {
                    callback('To use ReactHotModuleReplacement, you must install the NPM package \'aspnet-webpack-react\'.', null);
                    return;
                }
                aspNetWebpackReactModule.addReactHotModuleReplacementBabelTransform(webpackConfig);
            }
        }
        // Attach Webpack dev middleware and optional 'hot' middleware
        var compiler = webpack(webpackConfig);
        app.use(require('webpack-dev-middleware')(compiler, {
            noInfo: true,
            publicPath: publicPath
        }));
        if (enableHotModuleReplacement) {
            var webpackHotMiddlewareModule = void 0;
            try {
                webpackHotMiddlewareModule = require('webpack-hot-middleware');
            }
            catch (ex) {
                callback('To use HotModuleReplacement, you must install the NPM package \'webpack-hot-middleware\'.', null);
                return;
            }
            app.use(webpackHotMiddlewareModule(compiler));
        }
        // Tell the ASP.NET app what addresses we're listening on, so that it can proxy requests here
        callback(null, {
            Port: listener.address().port,
            PublicPath: removeTrailingSlash(getPath(publicPath))
        });
    });
}
exports.createWebpackDevServer = createWebpackDevServer;
function removeTrailingSlash(str) {
    if (str.lastIndexOf('/') === str.length - 1) {
        str = str.substring(0, str.length - 1);
    }
    return str;
}
function getPath(publicPath) {
    return url.parse(publicPath).path;
}
